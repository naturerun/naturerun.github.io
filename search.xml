<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/NTRWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
